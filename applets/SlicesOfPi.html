<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
"http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>Inside J2VM Interactive Illustrations - Slices of Pi</TITLE>
<META NAME="description" content="Slices of Pi (Java applet) - A
simulation of the Java virtual machine.">
<META NAME="keywords" content="Java Virtual Machine, calculating pi">
<META NAME="author" content="Bill Venners">
</HEAD>
<!--BEGIN_ARTIMA_COLOR_SCHEME-->
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#000099" VLINK="#009999" ALINK="#CC0000">
<!--END_ARTIMA_COLOR_SCHEME-->
<!--BEGIN_FISH_HEADING--> 
<CENTER>
<IMG src="images/fishhead.gif" alt="Interactive Illustrations for Inside the
Java 2 Virtual Machine">
</CENTER>
<!--END_FISH_HEADING--> 
<!--BEGIN_MAIN_TITLES-->
<FONT face="arial, helvetica" COLOR="#000066">
<FONT size=6>Slices of Pi</FONT><BR>
<FONT size=3>A Simulation of the Java Virtual Machine</FONT><BR>
</FONT>
<!--END_MAIN_TITLES-->
<!--BEGIN_TITLE_UNDERBAR-->
<HR align="left" width="85%">
<!--END_TITLE_UNDERBAR-->
<!--BEGIN_RIGHT_MARGIN_TABLE_TAG-->
<TABLE CELLPADDING="3" CELLSPACING="0" BORDER="0" width="85%">
<TR>
<TD  valign="top" rowspan="100">
<!--END_RIGHT_MARGIN_TABLE_TAG-->
<!--BEGIN_MAIN_BODY-->
<!--BEGIN_II_LINKS-->
<DIV id="links">
<CENTER>
<FONT size="1" face="geneva, arial, sans-serif">
<STRONG>
<A href="index.html">Interactive Illustrations</A>&nbsp;| 
<A href="http://www.artima.com/insidejvm/resources/">Resources Page</A>&nbsp;| 
<A href="http://www.artima.com/insidejvm/blurb.html">Order the Book</A>&nbsp;| 
<A href="HopAround.html">Previous</A>&nbsp;| 
<A href="author.html">Next</A>&nbsp; 
</STRONG>
</FONT>
</CENTER>
</DIV>
<!--END_II_LINKS-->

<p>The <i>Slices of Pi</i> applet, included below, demonstrates a Java virtual machine executing a sequence of bytecodes that calculates pi. This applet is described in Appendix D, &quot;Slices of Pi: A Simulation of the Java Virtual Machine&quot;, of <i>Inside the Java 2 Virtual Machine</i>.</p>

<center><p><applet CODE="SlicesOfPi.class" ARCHIVE="JVMSims.jar"
CODEBASE="JVMSimulators" WIDTH=600 HEIGHT=400><b>For some reason, your browser won't let you view this way cool Java applet.</b></applet></p></center>

<p> The bytecode sequence in the simulation was generated by <code>javac</code> for the <code>calculatePi()</code> method of the <code>PiCalculator</code> class shown below: 
</p>
<pre>
// On CD-ROM in file pi/ex1/PiCalculator.java
class PiCalculator {

    static void calculatePi() {

        double pi = 4.0;
        double sliceWidth = 0.5;
        double y;

        int iterations = 1;

        for (;;) {

            double x = 0.0;
            while (x < 1.0) {

                y = Math.sqrt(1 - (x * x));
                pi -= 4 * (sliceWidth * y);
                x += sliceWidth;

                y = Math.sqrt(1 - (x * x));
                pi += 4 * (sliceWidth * y);
                x += sliceWidth;
            }

            ++iterations;

            sliceWidth /= 2;
        }
    }
}
</pre>
<p><font SIZE="+1"><b>The Algorithm</b></font><br>The <code>calculatePi()</code> method loops forever in an attempt to find and capture the elusive pi, the ratio of the circumference of a circle to its diameter. To calculate pi, the <code>calculatePi()</code> method tries to determine the area of a circle that has a radius of one. Because the circle has a radius of one, the circle's area is pi itself.
</p>
<p>To determine the area of the circle with radius one, the <code>calculatePi()</code> method works to find the area of one fourth of the circle, then multiplies that area by four to get pi. Here's a diagram of a circle with the area that <code>calculatePi()</code> focuses on shown in blue:
</p>
<p align="center"><img src="images/circle.gif" ALT="Circle"></p>
<p>
To find the area of the portion of the circle shown in blue in the diagram above, the <code>calculatePi()</code> method slices the area up into progressively smaller rectangular segments, as shown in the diagram below:
</p>
<p align="center"><img src="images/slices.gif" ALT="Slices"></p>

<p>Because calculating the area of a rectangle is a piece of cake (or in this case, a slice of pi), the <code>calculatePi()</code> method is able to approximate pi by calculating and summing the areas of the rectangles, then multiplying the result by four. As you can see from the above diagram, this approach to calculating pi will always yield an approximation of pi that is too large. As the rectangles get thinner and more numerous, the approximation will get closer and closer to the real pi.
</p>

<p>The <code>calculatePi()</code> method works by making repeated passes at calculating the area of the quarter circle, with each subsequent pass using a smaller slice width. Each iteration of <code>calculatePi()</code>'s for loop represents one attempt to calculate the area of the quarter circle. For any particular iteration of the for loop, the <code>slicewidth</code> variable gives the x (horizontal) width of the slice, which remains constant during the entire iteration of the for loop. At the end of each for loop iteration, the slice with is halved.
</p>
<p>The value of the <code>pi</code> variable keeps a running record of the current approximation of pi. Each pass of <code>calculatePi()</code>'s for loop starts by initializing the <code>x</code> local variable to 0.0, then incrementing <code>x</code> by <code>slicewidth</code> until <code>x</code> reaches the end of the circle's radius at 1.0. 
</p>

<p>The while loop that is contained inside the for loop iterates once for every two slice widths. In effect, each iteration of the while loop takes a large rectangle from the previous iteration of the for loop, discards half of the large rectangle's area, and calculates a new value for the discarded portion. Because the slice width is halved at the end of each iteration of the for loop, the width of the rectangles calculated by the previous iteration of the for loop is always twice as wide as the slice width of the current iteration. Here is a diagram showing the steps the <code>calculatePi()</code> method takes to divide two rectangles into four:
</p>
<p align="center"><img src="images/progress.gif" ALT="Progress"></p>

<p><font SIZE="+1"><b>The Results of the Algorithm</b></font><br>For a better idea of what kind of results you can expect from the <code>calculatePi()</code> method, consider this close cousin to the <code>PiCalculator</code> class:
</p>
<pre>
// On CD-ROM in file pi/ex1/PiCalculatorPrinter.java
class PiCalculatorPrinter {

    static void calculateAndPrintPi() {

        double pi = 4.0;
        double sliceWidth = 0.5;
        double y;

        int iterations = 1;

        for (;;) {

            double x = 0.0;
            while (x < 1.0) {

                y = Math.sqrt(1 - (x * x));
                pi -= 4 * (sliceWidth * y);
                x += sliceWidth;

                y = Math.sqrt(1 - (x * x));
                pi += 4 * (sliceWidth * y);
                x += sliceWidth;
            }

            System.out.println(iterations + ": " + pi);
            ++iterations;

            sliceWidth /= 2;
        }
    }

    public static void main(String[] args) {
        calculateAndPrintPi();
    }
}
</pre>
<p>The <code>PiCalculatorPrinter.calculateAndPrintPi()</code> method uses the same algorithm to calculate pi as the <code>PiCalculator.calculatePi()</code> method, but along the way <code>calculateAndPrintPi()</code> reports its progress to the standard output. Here is the output of <code>PiCalculatorPrinter</code>, when it is run as a Java application and left to work for a while:
</p>
<pre>
1: 3.732050807568877
2: 3.4957090681024408
3: 3.339819144357174
4: 3.248253037827741
5: 3.1976024228771323
6: 3.170546912779685
7: 3.156405792396616
8: 3.1491180829572345
9: 3.145397402719659
10: 3.143509891539023
11: 3.1425565279114656
12: 3.1420764488577837
13: 3.1418352081747196
14: 3.1417141631514287
15: 3.141653490490536
16: 3.141623101073998
17: 3.1416078875969236
18: 3.1416002742226636
19: 3.141596465189377
20: 3.1415945598432646
21: 3.141593606876806
22: 3.1415931302901634
23: 3.1415928919598097
24: 3.1415927727818502
25: 3.1415927131888464
26: 3.1415926833899084
27: 3.141592668491482
28: 3.1415926610412166
29: 3.1415926573154693
</pre>

<p> The value of the static final <code>PI</code> field of class <code>java.lang.Math</code>, which is the <code>double</code> value that is closer than any other to the real value of pi, is 3.14159265358979323846. As you can see from the above output, after 29 iterations of the for loop, the algorithm has generated the first 9 significant decimal digits of pi: 3.14159265. As expected, all the approximations of pi are greater than the real value. The algorithm is approaching the real value of pi from above.
</p>

<p><font SIZE="+1"><b>The Bytecodes</b></font><br>The bytecodes generated by <code>javac</code> for the <code>calculatePi()</code> method are shown below:
</p>
<pre>
                   // Push dual-byte value from constant pool entry
                   // In this case, a double 4.0
 0 ldc2_w #10 <Double 4.0>
 3 dstore_0        // Pop double, store into local variables 0 and 1:
                   // double pi = 4;
                   // Push dual-byte value from constant pool entry
                   // In this case, a double 0.5
 4 ldc2_w #6 <Double 0.5>
 7 dstore_2        // Pop double, store into local variables 2 and 3:
                   // double slicewidth = 0.5;
 8 iconst_1        // Push int constant 1
 9 istore 6        // Pop int, store into local variable 6:
                   // int iterations = 1;
11 dconst_0        // Push double constant 0.0
12 dstore 7        // Pop double, store into local variables 7 and 8:
                   // double x = 0.0;
14 goto 75         // Jump to offset 75
17 dconst_1        // Push double constant 1.0
18 dload 7         // Push double from local variables 7 and 8 (x)
20 dload 7         // Push double from local variables 7 and 8 (x)
                   // Pop two doubles, multiply them, push double
22 dmul            // result
                   // Pop two doubles, subtract them, push double
23 dsub            // result
                   // Invoke the static method indicated by the
                   // constant entry, in this case Math.sqrt(double),
                   // which pops a double parameter and pushes a
                   // double return value
24 invokestatic #5 <Method double sqrt(double)>
                   // Pop double, store into local variables 4 and 5:
27 dstore 4        // y = Math.sqrt(1 - (x * x));
29 dload_0         // Push double from local variables 0 and 1 (pi)
                   // Push dual-byte value from constant pool entry
                   // In this case, a double 4.0
30 ldc2_w #10 <Double 4.0>
                   // Push double from local variables 2 and 3
33 dload_2         // (slicewidth)
34 dload 4         // Push double from local variables 4 and 5 (y)
                   // Pop two doubles, multiply them, push double
36 dmul            // result
                   // Pop two doubles, multiply them, push double
37 dmul            // result
                   // Pop two doubles, subtract them, push double
38 dsub            // result
                   // Pop double, store into local variables 0 and 1:
39 dstore_0        // pi -= 4 * (slicewidth * y);
40 dload 7         // Push double from local variables 7 and 8 (x)
                   // Push double from local variables 2 and 3
42 dload_2         // (slicewidth)
43 dadd            // Pop two doubles, add them, push double result
                   // Pop double, store into local variables 7 and 8:
44 dstore 7        // x += slicewidth;
46 dconst_1        // Push double constant 1.0
47 dload 7         // Push double from local variables 7 and 8 (x)
49 dload 7         // Push double from local variables 7 and 8 (x)
                   // Pop two doubles, multiply them, push double
51 dmul            // result
                   // Pop two doubles, subtract them, push double
52 dsub            // result
                   // Invoke the static method indicated by the
                   // constant entry, in this case Math.sqrt(double),
                   // which pops a double parameter and pushes a
                   // double return value
53 invokestatic #5 <Method double sqrt(double)>
                   // Pop double, store into local variables 4 and 5:
56 dstore 4        // y = Math.sqrt(1 - (x * x));
58 dload_0         // Push double from local variables 0 and 1 (pi)
                   // Push dual-byte value from constant pool entry
                   // In this case, a double 4.0
59 ldc2_w #10 <Double 4.0>
                   // Push double from local variables 2 and 3
62 dload_2         // (slicewidth)
63 dload 4         // Push double from local variables 4 and 5 (y)
                   // Pop two doubles, multiply them, push double
65 dmul            // result
                   // Pop two doubles, multiply them, push double
66 dmul            // result
67 dadd            // Pop two doubles, add them, push double result
                   // Pop double, store into local variables 0 and 1:
68 dstore_0        // pi += 4 * (slicewidth * y);
69 dload 7         // Push double from local variables 7 and 8 (x)
                   // Push double from local variables 2 and 3
71 dload_2         // (slicewidth)
72 dadd            // Pop two doubles, add them, push double result
                   // Pop double, store into local variables 7 and 8:
73 dstore 7        // x += slicewidth;
75 dload 7         // Push double from local variables 7 and 8 (x)
77 dconst_1        // Push double constant 1.0
78 dcmpg           // Pop two doubles, compare them, push int result
                   // Pop int, branch if less than zero to offset 17:
79 iflt 17         // while (x < 1.0) {}
82 iinc 6 1        // Increment local variable 6 by 1: ++iterations;
                   // Push double from local variables 2 and 3
85 dload_2         // (slicewidth)
                   // Push dual-byte value from constant pool entry
                   // In this case, a double 2.0
86 ldc2_w #8 <Double 2.0>
                   // Pop two doubles, divide them, push double
89 ddiv            // result
                   // Pop double, store into local variables 2 and 3:
90 dstore_2        // slicewidth /= 2;
91 goto 11         // Jump unconditionally to offset 11: for(;;) {}
</pre>

<p>Note that the <code>calculatePi()</code> method includes a few good demonstrations of the way in which the Java virtual machine calculates larger expressions using the operand stack. To calculate the &quot;<code>pi -= 4 * (slicewidth * y);</code>&quot; expression, for example, the Java virtual machine pushes all four values (<code>pi</code>, 4.0, <code>slicewidth</code>, and <code>y</code>) onto the operand stack, then performs two multiply instructions and a subtract, finally storing the result into the <code>pi</code> local variable. In addition, to calculate &quot;<code>(1 - (x * x))</code>&quot;, the Java virtual machine pushes all three values (1, <code>x</code>, and <code>x</code>) onto the operand stack, then performs a multiply and a subtract.
</p>

<p><font SIZE="+1"><b>The Trouble with <code>double</code></b></font><br>The <code>calculatePi()</code> method has two major problems. First, it takes a long time to get even a few significant digits of pi. Its inherent slowness is compounded by the fact that it is running in a simulated Java virtual machine that only executes about two instructions a second.
</p>
<p>The other major problem with the <code>calculatePi()</code> method is that it doesn't deal with rounding errors. Although the <code>calculatePi()</code> method will indeed execute forever, eventually the <code>sliceWidth /= 2;</code> statement will cause the value of <code>sliceWidth</code> to underflow to zero. After that, the value of the <code>pi</code> variable will never change, but its value won't be equal to <code>Math.PI</code> because of rounding errors that accumulate prior to the <code>pi</code> variable reaching its final value.
</p>
<p>Despite these problems, the <code>calculatePi()</code> method does serve as a good example of the Java virtual machine operating on <code>double</code>s and calculating larger expressions.
</p>
<p><font SIZE="+1"><b>Running the Applet</b></font><br>As you run the simulation, you can monitor the progress of the <code>calculatePi()</code> method by watching the local variables portion of the stack frame. The local variables  of <code>calculatePi()</code> were arranged by the <code>javac</code> compiler into the local variable slots of the stack frame as follows:
</p>
<center><TABLE BORDER="1" WIDTH="200">
<TR><TH><center>local variable</center></TH><TH><center>slot(s)</center></TH></TR>
<TR><TD><center><code>pi</code></center></TD><TD><center>0 and 1</center></TD></TR>
<TR><TD><center><code>slicewidth</code></center></TD><TD><center>2 and 3</center></TD></TR>
<TR><TD><center><code>y</code></center></TD><TD><center>4 and 5</center></TD></TR>
<TR><TD><center><code>iterations</code></center></TD><TD><center>6</center></TD></TR>
<TR><TD><center><code>x</code></center></TD><TD><center>7 and 8</center></TD></TR>
</TABLE>
</center>

<p>To drive the <i>Slices of Pi</i> simulation, use the Step, Reset, Run, and Stop buttons. Each time you press the Step button, the simulator will execute the instruction pointed to by the pc register. If you press the Run button, the simulation will continue with no further coaxing on your part until you press the Stop button. To start the simulation over, press the Reset button. Happy clicking.</p>
</p>
<p><HR WIDTH=500></p>
<p>
Click here to view a page of links to the <a href="sourcecode.html#jvmsim">source code</a> of the <i>Slices of Pi</i> applet.
</p>


<!--BEGIN_II_LINKS-->
<DIV id="links">
<CENTER>
<FONT size="1" face="geneva, arial, sans-serif">
<STRONG>
<A href="index.html">Interactive Illustrations</A>&nbsp;| 
<A href="http://www.artima.com/insidejvm/resources/">Resources Page</A>&nbsp;| 
<A href="http://www.artima.com/insidejvm/blurb.html">Order the Book</A>&nbsp;| 
<A href="HopAround.html">Previous</A>&nbsp;| 
<A href="author.html">Next</A>&nbsp; 
</STRONG>
</FONT>
</CENTER>
</DIV>
<!--END_II_LINKS-->
<!--END_MAIN_BODY-->
<!--BEGIN_RIGHT_MARGIN_TABLE_CLOSE-->
</TD>
</TR>
</TABLE>
<!--END_RIGHT_MARGIN_TABLE_CLOSE-->
<!--BEGIN_FOOTER_SEPARATOR-->
<HR width="100%">
<!--END_FOOTER_SEPARATOR-->
<!--BEGIN_FOOTER-->
<TABLE width="100%">
<TR>
<TD align="left">
<FONT size="1" face="geneva, arial, sans-serif">
<!--REG_COPYRIGHT_LINE--><A href="copyright.html">Copyright</A> &copy; 1996-1999 Bill Venners. All Rights Reserved.
</FONT>
</TD>
</TR>
</TABLE>
<!--END_FOOTER-->
</body>
</html>
