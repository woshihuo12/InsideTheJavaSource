<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
"http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>Inside J2VM Interactive Illustrations - Hop Around</TITLE>
<META NAME="description" content="Hop Around (Java applet) - A
simulation of the Java virtual machine.">
<META NAME="keywords" content="Java Virtual Machine, Java finally clause">
<META NAME="author" content="Bill Venners">
</HEAD>
<!--BEGIN_ARTIMA_COLOR_SCHEME-->
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#000099" VLINK="#009999" ALINK="#CC0000">
<!--END_ARTIMA_COLOR_SCHEME-->
<!--BEGIN_FISH_HEADING--> 
<CENTER>
<IMG src="images/fishhead.gif" alt="Interactive Illustrations for Inside the
Java 2 Virtual Machine">
</CENTER>
<!--END_FISH_HEADING--> 
<!--BEGIN_MAIN_TITLES-->
<FONT face="arial, helvetica" COLOR="#000066">
<FONT size=6>Hop Around</FONT><BR>
<FONT size=3>A Simulation of the Java Virtual Machine</FONT><BR>
</FONT>
<!--END_MAIN_TITLES-->
<!--BEGIN_TITLE_UNDERBAR-->
<HR align="left" width="85%">
<!--END_TITLE_UNDERBAR-->
<!--BEGIN_RIGHT_MARGIN_TABLE_TAG-->
<TABLE CELLPADDING="3" CELLSPACING="0" BORDER="0" width="85%">
<TR>
<TD  valign="top" rowspan="100">
<!--END_RIGHT_MARGIN_TABLE_TAG-->
<!--BEGIN_MAIN_BODY-->
<!--BEGIN_II_LINKS-->
<DIV id="links">
<CENTER>
<FONT size="1" face="geneva, arial, sans-serif">
<STRONG>
<A href="index.html">Interactive Illustrations</A>&nbsp;| 
<A href="http://www.artima.com/insidejvm/resources/">Resources Page</A>&nbsp;| 
<A href="http://www.artima.com/insidejvm/blurb.html">Order the Book</A>&nbsp;| 
<A href="PlayBall.html">Previous</A>&nbsp;| 
<A href="SlicesOfPi.html">Next</A>&nbsp; 
</STRONG>
</FONT>
</CENTER>
</DIV>
<!--END_II_LINKS-->

<p>The <i>Hop Around</i> applet, included below, demonstrates a Java virtual machine executing a sequence of bytecodes. This applet accompanies Chapter 18, &quot;Finally Clauses,&quot; of <i>Inside the Java 2 Virtual Machine</i>.</p>

<center><p><applet CODE="HopAround.class" ARCHIVE="JVMSims.jar"
CODEBASE="JVMSimulators" WIDTH=600 HEIGHT=370><b>For some reason, your browser won't let you view this way cool Java applet.</b></applet></p></center>

<p>The bytecode sequence in the simulation was generated by the <code>javac</code> compiler for the <code>hopAround()</code> method of the class shown below:
</p>
<pre>
// On CD-ROM in file opcodes/ex1/Clown.java
class Clown {

    static int hopAround() {
        int i = 0;
        while (true) {
            try {
                try {
                    i = 1;
                }
                finally {  // The first finally clause
                    i = 2;
                }
                i = 3;
                // This return never completes, because of
                // the continue in the second finally clause
                return i;
            }
            finally {      // The second finally clause
                if (i == 3) {
                     // This continue overrides the return statement
                    continue;
                }
            }
        }
    }
}
</pre>
<p>The bytecodes generated by <code>javac</code> for the <code>hopAround()</code> method are shown here:
</p>
<pre>
 0 iconst_0      // Push constant 0
 1 istore_0      // Pop into local var 0: int i = 0;

// Both try blocks start here (see exception table, below):
 2 iconst_1      // Push constant 1
 3 istore_0      // Pop into local var 0: i = 1;
 4 jsr 18        // Jump to mini-subroutine at offset 18 (the
                 // first finally clause)
 7 goto 24       // Jump to offset 24 (to just below first
                 // finally clause)

// Catch clause for the first finally clause:
10 astore 4      // Pop the reference to thrown exception, store
                 // in local variable 4
12 jsr 18        // Jump to mini-subroutine at offset 18 (the
                 // first finally clause)
15 aload 4       // Push the reference (to thrown exception)
                 // from local variable 4
17 athrow        // Rethrow the same exception

// The first finally clause:
18 astore 5      // Store the return address in local variable 5
20 iconst_2      // Push constant 2
21 istore_0      // Pop into local var 0: i = 2;
22 ret 5         // Jump to return address stored in local variable 5

// Bytecodes for the code just after the first finally clause:
24 iconst_3      // Push constant 3
25 istore_0      // Pop into local var 0: int i = 3;

// Bytecodes for the return statment:
26 iload_0       // Push the int from local
                 // variable 0 (i, which is 3)
27 istore_1      // Pop and store the int into local
                 // variable 1 (the return value, i)
28 jsr 39        // Jump to mini-subroutine at offset 39 (the
                 // second finally clause)
31 iload_1       // Push the int from local variable 1 (the
                 // return value)
32 ireturn       // Return the int on the top of the stack

// Catch clause for the second finally clause:
33 astore_2      // Pop the reference to thrown exception, store
                 // in local variable 2
34 jsr 39        // Jump to mini-subroutine at offset 39 (the
                 // second finally clause)
37 aload_2       // Push the reference (to thrown exception)
                 // from local variable 2
38 athrow        // Rethrow the same exception

// The second finally clause:
39 astore_3      // Store the return address in local variable 3
40 iload_0       // Push the int from local variable 0 (i)
41 iconst_3      // Push constant 3
42 if_icmpeq 47  // If the top two ints on the stack are equal, jump
                 // to offset 47: if (i == 3) {
45 ret 3         // Jump to return address stored in local variable 3
47 goto 2        // Jump to offset 2 (the top of the while
                 // block): continue;

Exception table:
   from   to  target type
     2     4    10   any
     2    31    31   any
</pre>
<p>The <code>hopAround()</code> method returns from the first <code>finally</code> clause by executing past the closing curly brace, but returns from the second <code>finally</code> clause by executing a <code>continue</code> statement. The first <code>finally</code> clause, therefore, exits via its <code>ret</code> instruction. But because the second <code>finally</code> clause exits via a <code>continue</code>, its <code>ret</code> instruction is never executed. The <code>continue</code> statement causes the Java virtual machine to jump to the top of the <code>while</code> loop again. This results in an endless loop, even though it is a <code>return</code> statement that originally causes the second <code>finally</code> clause to be executed in the first place. The continue statement in the <code>finally</code> clause supersedes the <code>return</code> statement, so the method never returns. 
</p>
<p>Note that the bytecodes that implement the <code>return</code> statement store a copy of the return value into local variable one before jumping to the miniature subroutine that represents the second <code>finally</code> clause. Then, after the miniature subroutine returns (in this case it never does, because the continue is always executed), the return value is retrieved from local variable one and returned.
</p>
<p>This highlights the way the Java virtual machine returns values when <code>finally</code> clauses are also executed. Rather than returning the value of <code>i</code> after the <code>finally</code> clause is executed, the Java virtual machine will return the value that <code>i</code> had just <i>before</i> the <code>finally</code> clause was executed. This means that even if the <code>finally</code> clause changes the value of <code>i</code>, the method will still return the value that <code>i</code> had when the <code>return</code> statement was first reached, before the <code>finally</code> clause was invoked. If you wanted the <code>finally</code> clause to be able to change the return value of the method, you would have to put an actual <code>return</code> statement with the new return value into the <code>finally</code> clause itself. 
</p>
<p>To drive the <i>Hop Around</i> simulation, use the Step, Reset, Run, and Stop buttons. Each time you press the Step button, the simulator will execute the instruction pointed to by the pc register. If you press the Run button, the simulation will continue with no further coaxing on your part until you press the Stop button. To start the simulation over, press the Reset button. For each step of the simulation, a panel at the bottom of the applet contains an explanation of what the next instruction will do. Happy clicking.
</p>

<p><HR WIDTH=500></p>
<p>
Click here to view a page of links to the <a href="sourcecode.html#jvmsim">source code</a> of the <i>Hop Around</i> applet.
</p>


<!--BEGIN_II_LINKS-->
<DIV id="links">
<CENTER>
<FONT size="1" face="geneva, arial, sans-serif">
<STRONG>
<A href="index.html">Interactive Illustrations</A>&nbsp;| 
<A href="http://www.artima.com/insidejvm/resources/">Resources Page</A>&nbsp;| 
<A href="http://www.artima.com/insidejvm/blurb.html">Order the Book</A>&nbsp;| 
<A href="PlayBall.html">Previous</A>&nbsp;| 
<A href="SlicesOfPi.html">Next</A>&nbsp; 
</STRONG>
</FONT>
</CENTER>
</DIV>
<!--END_II_LINKS-->
<!--END_MAIN_BODY-->
<!--BEGIN_RIGHT_MARGIN_TABLE_CLOSE-->
</TD>
</TR>
</TABLE>
<!--END_RIGHT_MARGIN_TABLE_CLOSE-->
<!--BEGIN_FOOTER_SEPARATOR-->
<HR width="100%">
<!--END_FOOTER_SEPARATOR-->
<!--BEGIN_FOOTER-->
<TABLE width="100%">
<TR>
<TD align="left">
<FONT size="1" face="geneva, arial, sans-serif">
<!--REG_COPYRIGHT_LINE--><A href="copyright.html">Copyright</A> &copy; 1996-1999 Bill Venners. All Rights Reserved.
</FONT>
</TD>
</TR>
</TABLE>
<!--END_FOOTER-->
</body>
</html>
